// _bOSs_coders
// RTC - Initialization and driver
// Andrew Smith
//     3/11/17
//-------------------------------------------------------------------

#include "rtc.h"
#include "pit.h"
#include "i8259.h"
#include "lib.h"
#include "pcb.h"
#define FREQ1  2
#define FREQ2  4
#define FREQ3  8
#define FREQ4  16
#define FREQ5  32
#define FREQ6  64
#define FREQ7  128
#define FREQ8  256
#define FREQ9  512
#define FREQ10 1024
#define RATE1  15
#define RATE2  14
#define RATE3  13
#define RATE4  12
#define RATE5  11
#define RATE6  10
#define RATE7  9
#define RATE8  8
#define RATE9  7
#define RATE10 6
#define RATE_MASK 0x0F
#define NUM_PROC 3
#define IRQ_RTC 8
#define RTC_OUT_VAL 0x80
#define RTC_OUT_VAL2 0x40
#define TOP_4_MASK 0xF0

// RTC Functions
//-------------------------------------------------------------------
/*
 * rtc_handler
 *   DESCRIPTION: generated by the rtc
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: sends end of interrupt signal, sets our rtc_flag = 1 used by the read function
 */
 void rtc_handler(void) {

   // send the "RTC EOI"
   rtc_eoi();
   int i = 0;
   for (i = 0; i < NUM_PROC; i++){
     rtc_flag[i] = 1;
   }
      // send the "RTC EOI" irq 8
   send_eoi(IRQ_RTC);

   return;
}

/*
 * rtc_init
 *   DESCRIPTION: initializes the rtc
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: wrapper for rtc_enable, Enable (unmask) the IRQ 8
 */
 void rtc_init() {
    rtc_enable();
    enable_irq(IRQ_RTC);
    return;
}

/*
 *   rtc_enable
 *   DESCRIPTION: turns on periodic interrupts
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: turns on the periodic interrupt on IRQ 8
 */
void rtc_enable() {
    unsigned char prev;
//    unsigned int rate = 15;

    outb(RTC_OUT_VAL | RTC_STATUS_B, RTC_REG);
    prev = inb(RTC_CMOS);
    outb(RTC_OUT_VAL | RTC_STATUS_B, RTC_REG);
    outb(prev | RTC_OUT_VAL2, RTC_CMOS);
    return;
}


/*
 *   rtc_disable
 *   DESCRIPTION: disables the rtc
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: turns off the periodic interrupt on IRQ 8
 */
void rtc_disable() {
    unsigned char prev;

    outb(RTC_STATUS | RTC_STATUS_B, RTC_REG);
    prev = inb(RTC_CMOS);
    outb(RTC_STATUS | RTC_STATUS_B, RTC_REG);
    outb(~(prev | RTC_OUT_VAL2), RTC_CMOS); //turn on bit 6 of register b

    return;
}


/*
 *   rtc_eoi
 *   DESCRIPTION: sends end of interrupt
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: reads register c to allow next interrupt, This must be sent at the end of the interrupt handler for RTC
 */
void rtc_eoi() {

  outb(RTC_STATUS_C, RTC_REG);
  inb(RTC_CMOS);
  return;
}

/*
 *   rtc_read
 *   DESCRIPTION: waits one clock cycle
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: dela
 */
int32_t rtc_read(int32_t fd, void* buf, int32_t n_bytes, void* cur_file)
{
  //printf("reading rtc\n");
  (void) fd;
  (void) buf;
  (void) n_bytes;
  (void) cur_file;
  PCB* cur_pcb = get_pcb();
  rtc_flag[cur_pcb->term_parent] = 0;
  while(1)
  {
    if (rtc_flag[cur_pcb->term_parent] == 1) break;
  }
  return 0;
}

/*
 *   rtc_write
 *   DESCRIPTION: change the frequency of the clock
 *   INPUTS: pointer to the frequency
 *   OUTPUTS: return 0 on success, -1 on failure
 *   RETURN VALUE:  return 0 on success, -1 on failure
 *   SIDE EFFECTS: changes the clock speed, for periodic interrupts
 */
int32_t rtc_write(int32_t fd, const void* buf, int32_t n_bytes, void* cur_file)
{
  (void) n_bytes;
  (void) fd;
  unsigned char prev;
  int32_t rate = 0;
  int32_t frequency;
  int i;
  for (i = 0; i < NUM_PROC; i++) rtc_flag[i] =1;
  if ((int32_t*)buf)
  {
    frequency = *(int32_t*)buf;

    switch ( frequency ) {
      case FREQ1:
        rate = RATE_MASK & RATE1;
        break;
      case FREQ2:
        rate = RATE_MASK & RATE2;
        break;
      case FREQ3:
        rate = RATE_MASK & RATE3;
        break;
      case FREQ4:
        rate = RATE_MASK & RATE4;
        break;
      case FREQ5:
        rate = RATE_MASK & RATE5;
        break;
      case FREQ6:
        rate = RATE_MASK & RATE6;
        break;
      case FREQ7:
       rate = RATE_MASK & RATE7;
        break;
      case FREQ8:
        rate = RATE_MASK & RATE8;
        break;
      case FREQ9:
        rate = RATE_MASK & RATE9;
        break;
      case FREQ10:
        rate = RATE_MASK & RATE10;
        break;

      default:
        return -1; //when we dont have a valid freq
        break;
      }
     cli(); //clear interrupts and change the frequency
     outb(RTC_STATUS | RTC_STATUS_A, RTC_REG);
     prev = inb(RTC_CMOS);
     outb(RTC_STATUS | RTC_STATUS_A, RTC_REG);
     outb((prev & TOP_4_MASK) | rate, RTC_CMOS);
     sti();
     return 0; //success
  }
  return -1; //we were passed a null pointer!

}

/*
 *   rtc_open
 *   DESCRIPTION: placeholder, returns 0
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE:  0
 *   SIDE EFFECTS: none
 */
int32_t rtc_open(const uint8_t* filename){
    (void) filename;
    return 0;
}

/*
 *   rtc_close
 *   DESCRIPTION: placeholder, returns 0
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE:  0
 *   SIDE EFFECTS: none
 */
int32_t rtc_close(void){
    return 0;
}
